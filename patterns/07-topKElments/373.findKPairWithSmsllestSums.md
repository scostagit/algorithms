
#  373. Find K Pair with smsllest Sums

We are given two **sorted arrays**, `nums1` and `nums2`.

We must find **k pairs** `(u, v)` (where `u` is from `nums1` and `v` is from `nums2`) that have the **smallest possible sums** (`u + v`).

---

### âœ¨ Example

```
nums1 = [1, 7, 11]
nums2 = [2, 4, 6]
k = 3
```

All possible pairs (and their sums):

| Pair   | Sum |
| ------ | --- |
| [1,2]  | 3   |
| [1,4]  | 5   |
| [1,6]  | 7   |
| [7,2]  | 9   |
| [7,4]  | 11  |
| [11,2] | 13  |
| [7,6]  | 13  |
| [11,4] | 15  |
| [11,6] | 17  |

We sort by sum â†’ the **3 smallest sums** are `[1,2], [1,4], [1,6]`.

---

### ğŸ§© But we canâ€™t generate *all pairs* (too slow!)

If `nums1` and `nums2` each have 100,000 elements, there could be **10 billion pairs** â€” impossible to compute directly.

So we need a **smarter way**.

---

## âš™ï¸ **The Efficient Idea: Use a Min-Heap**

A **min-heap (priority queue)** is a structure that always gives you the *smallest element first*.

Hereâ€™s the trick:

1. **Start with pairs** `(nums1[i], nums2[0])` for all `i`.

   * Because both arrays are sorted, `(nums1[i], nums2[0])` will be the smallest sum for each `nums1[i]`.

2. **Put those pairs in a min-heap**, ordered by their sum (`nums1[i] + nums2[j]`).

3. **Extract (pop)** the smallest pair from the heap â€” add it to your result.

4. When you pop `(nums1[i], nums2[j])`, **push the next pair** `(nums1[i], nums2[j + 1])` (the next number from `nums2`).

5. Repeat until we get **k pairs**.

---

### ğŸ§  Why this works

We only explore the **next smallest possible pair** each time, instead of all pairs.
This gives us the correct order **without generating everything**.

---

## âœ… **Step-by-step JavaScript solution**

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */
var kSmallestPairs = function(nums1, nums2, k) {
    // Edge case: if any array is empty, return []
    if (nums1.length === 0 || nums2.length === 0) return [];

    // We'll use a min-heap (priority queue)
    // In JS we can simulate one using a simple array + sorting
    let heap = [];

    // Step 1: Push the first element from nums2 for each nums1[i]
    for (let i = 0; i < Math.min(nums1.length, k); i++) {
        heap.push([nums1[i], nums2[0], 0]); 
        // [value from nums1, value from nums2, index in nums2]
    }

    let result = [];

    // Step 2: While we still need pairs and the heap isn't empty
    while (k > 0 && heap.length > 0) {

        // Sort heap to get smallest sum on top
        heap.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));

        // Take the smallest sum pair
        let [num1, num2, idx2] = heap.shift(); // pop the smallest
        result.push([num1, num2]);

        // Step 3: Push the next pair (same num1, next num2)
        if (idx2 + 1 < nums2.length) {
            heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
        }

        k--; // we found one of the k pairs
    }

    return result;
};
```

---

## ğŸ’¬ **Line-by-line Explanation**

```js
if (nums1.length === 0 || nums2.length === 0) return [];
```

â†’ If one array is empty, there are no pairs.

```js
let heap = [];
```

â†’ We'll use this as a simple min-heap.

```js
for (let i = 0; i < Math.min(nums1.length, k); i++) {
    heap.push([nums1[i], nums2[0], 0]);
}
```

â†’ We start with the smallest possible pairs:
each `nums1[i]` combined with the **first element of nums2**.

---

```js
while (k > 0 && heap.length > 0) {
    heap.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));
```

â†’ Sort heap so that the smallest sum is first (in production, weâ€™d use a real priority queue for speed).

---

```js
let [num1, num2, idx2] = heap.shift();
result.push([num1, num2]);
```

â†’ Take the smallest pair from the heap and add it to our result.

---

```js
if (idx2 + 1 < nums2.length) {
    heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
}
```

â†’ Move to the next possible pair with the same `num1` but the next `num2`.

---

```js
k--;
```

â†’ Decrease the counter â€” we found one of the desired pairs.

---

âœ… **Return the result**

```js
return result;
```

---

## ğŸ§ª **Example Run**

```js
nums1 = [1,7,11]
nums2 = [2,4,6]
k = 3
```

Step 1: Heap initially
â†’ `[[1,2,0],[7,2,0],[11,2,0]]`

Pop `[1,2]` â†’ push `[1,4]`
Pop `[1,4]` â†’ push `[1,6]`
Pop `[1,6]` â†’ done.

âœ… Output: `[[1,2],[1,4],[1,6]]`

---








## Portuguese explaination


### ğŸ§  Ideia geral

Temos dois arrays **ordenados**:

```js
nums1 = [1,7,11]
nums2 = [2,4,6]
```

E queremos os **k menores pares possÃ­veis**, onde cada par Ã© formado por:

* um nÃºmero do `nums1`
* e um nÃºmero do `nums2`.

Exemplo:
Todos os pares possÃ­veis sÃ£o:

```
[1,2], [1,4], [1,6],
[7,2], [7,4], [7,6],
[11,2], [11,4], [11,6]
```

Mas nÃ£o queremos todos, sÃ³ os **3 com menor soma** â†’ `[1,2], [1,4], [1,6]`.

---

### ğŸ§© Passo a passo do algoritmo

1. **Verifica se os arrays estÃ£o vazios.**
   Se um deles estiver vazio, nÃ£o hÃ¡ pares possÃ­veis â†’ retorna `[]`.

   ```js
   if(nums1.length === 0 || nums2.length === 0) return [];
   ```

---

2. **Cria uma "lista de possÃ­veis pares" (heap).**
   O heap aqui Ã© sÃ³ um **array que serÃ¡ ordenado** a cada passo (em vez de um heap de verdade).

   Ele comeÃ§a pegando o **primeiro elemento de `nums2`** combinado com alguns elementos iniciais de `nums1`:

   ```js
   for (let i = 0; i < Math.min(nums1.length, k); i++) {
       heap.push([nums1[i], nums2[0], 0]);
   }
   ```

   ğŸ‘‰ Isso significa: â€œcomece testando todos os nÃºmeros de `nums1` com o primeiro nÃºmero de `nums2`â€.

   Exemplo:

   ```
   heap = [
     [1, 2, 0],
     [7, 2, 0],
     [11, 2, 0]
   ]
   ```

   (o `0` no final Ã© o Ã­ndice de onde ele estÃ¡ em `nums2`)

---

3. **Enquanto ainda faltarem pares (k > 0):**

   * Ordena o heap pelo **menor valor da soma (`num1 + num2`)**
   * Pega o **menor par** (tirando o primeiro da lista)
   * Guarda esse par no resultado

   ```js
   heap.sort((a,b) => (a[0]+a[1]) - (b[0]+b[1]));
   let [num1, num2, idx2] = heap.shift();
   result.push([num1, num2]);
   ```

---

4. **Cria o â€œprÃ³ximo par possÃ­velâ€ com o mesmo `num1`, mas o prÃ³ximo nÃºmero de `nums2`.**

   ```js
   if (idx2 + 1 < nums2.length) {
       heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
   }
   ```

   ğŸ‘‰ Assim, ele vai avanÃ§ando no `nums2` sem precisar gerar todos os pares de uma vez.

---

5. **Repete atÃ© achar k pares.**

   Cada vez:

   * tira o menor par da lista
   * adiciona o prÃ³ximo par com o mesmo `num1` e o prÃ³ximo `num2`.

---

### ğŸ§® Exemplo simplificado

Com `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`:

| Passo | heap antes de ordenar      | Pega (menor soma) | Adiciona prÃ³ximo par | Resultado acumulado |
| ----- | -------------------------- | ----------------- | -------------------- | ------------------- |
| 1     | [[1,2,0],[7,2,0],[11,2,0]] | [1,2]             | [1,4,1]              | [[1,2]]             |
| 2     | [[7,2,0],[11,2,0],[1,4,1]] | [1,4]             | [1,6,2]              | [[1,2],[1,4]]       |
| 3     | [[7,2,0],[11,2,0],[1,6,2]] | [1,6]             | â€”                    | [[1,2],[1,4],[1,6]] |

âœ… Pronto: encontramos os 3 menores pares.

---

### ğŸ’¡ Resumo bem curto

O algoritmo:

1. ComeÃ§a com os pares menores possÃ­veis.
2. Sempre pega o menor par atual.
3. Gera o **prÃ³ximo par possÃ­vel** sÃ³ quando precisa.
4. Repete atÃ© achar `k` pares.


