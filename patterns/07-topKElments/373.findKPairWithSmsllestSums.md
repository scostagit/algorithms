
#  373. Find K Pair with smsllest Sums

We are given two **sorted arrays**, `nums1` and `nums2`.

We must find **k pairs** `(u, v)` (where `u` is from `nums1` and `v` is from `nums2`) that have the **smallest possible sums** (`u + v`).

---

### ‚ú® Example

```
nums1 = [1, 7, 11]
nums2 = [2, 4, 6]
k = 3
```

All possible pairs (and their sums):

| Pair   | Sum |
| ------ | --- |
| [1,2]  | 3   |
| [1,4]  | 5   |
| [1,6]  | 7   |
| [7,2]  | 9   |
| [7,4]  | 11  |
| [11,2] | 13  |
| [7,6]  | 13  |
| [11,4] | 15  |
| [11,6] | 17  |

We sort by sum ‚Üí the **3 smallest sums** are `[1,2], [1,4], [1,6]`.

---

### üß© But we can‚Äôt generate *all pairs* (too slow!)

If `nums1` and `nums2` each have 100,000 elements, there could be **10 billion pairs** ‚Äî impossible to compute directly.

So we need a **smarter way**.

---

## ‚öôÔ∏è **The Efficient Idea: Use a Min-Heap**

A **min-heap (priority queue)** is a structure that always gives you the *smallest element first*.

Here‚Äôs the trick:

1. **Start with pairs** `(nums1[i], nums2[0])` for all `i`.

   * Because both arrays are sorted, `(nums1[i], nums2[0])` will be the smallest sum for each `nums1[i]`.

2. **Put those pairs in a min-heap**, ordered by their sum (`nums1[i] + nums2[j]`).

3. **Extract (pop)** the smallest pair from the heap ‚Äî add it to your result.

4. When you pop `(nums1[i], nums2[j])`, **push the next pair** `(nums1[i], nums2[j + 1])` (the next number from `nums2`).

5. Repeat until we get **k pairs**.

---

### üß† Why this works

We only explore the **next smallest possible pair** each time, instead of all pairs.
This gives us the correct order **without generating everything**.

---

## ‚úÖ **Step-by-step JavaScript solution**

```js
/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */
var kSmallestPairs = function(nums1, nums2, k) {
    // Edge case: if any array is empty, return []
    if (nums1.length === 0 || nums2.length === 0) return [];

    // We'll use a min-heap (priority queue)
    // In JS we can simulate one using a simple array + sorting
    let heap = [];

    // Step 1: Push the first element from nums2 for each nums1[i]
    for (let i = 0; i < Math.min(nums1.length, k); i++) {
        heap.push([nums1[i], nums2[0], 0]); 
        // [value from nums1, value from nums2, index in nums2]
    }

    let result = [];

    // Step 2: While we still need pairs and the heap isn't empty
    while (k > 0 && heap.length > 0) {

        // Sort heap to get smallest sum on top
        heap.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));

        // Take the smallest sum pair
        let [num1, num2, idx2] = heap.shift(); // pop the smallest
        result.push([num1, num2]);

        // Step 3: Push the next pair (same num1, next num2)
        if (idx2 + 1 < nums2.length) {
            heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
        }

        k--; // we found one of the k pairs
    }

    return result;
};
```

---

## üí¨ **Line-by-line Explanation**

```js
if (nums1.length === 0 || nums2.length === 0) return [];
```

‚Üí If one array is empty, there are no pairs.

```js
let heap = [];
```

‚Üí We'll use this as a simple min-heap.

```js
for (let i = 0; i < Math.min(nums1.length, k); i++) {
    heap.push([nums1[i], nums2[0], 0]);
}
```

‚Üí We start with the smallest possible pairs:
each `nums1[i]` combined with the **first element of nums2**.

---

```js
while (k > 0 && heap.length > 0) {
    heap.sort((a, b) => (a[0] + a[1]) - (b[0] + b[1]));
```

‚Üí Sort heap so that the smallest sum is first (in production, we‚Äôd use a real priority queue for speed).

---

```js
let [num1, num2, idx2] = heap.shift();
result.push([num1, num2]);
```

‚Üí Take the smallest pair from the heap and add it to our result.

---

```js
if (idx2 + 1 < nums2.length) {
    heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
}
```

‚Üí Move to the next possible pair with the same `num1` but the next `num2`.

---

```js
k--;
```

‚Üí Decrease the counter ‚Äî we found one of the desired pairs.

---

‚úÖ **Return the result**

```js
return result;
```

---

## üß™ **Example Run**

```js
nums1 = [1,7,11]
nums2 = [2,4,6]
k = 3
```

Step 1: Heap initially
‚Üí `[[1,2,0],[7,2,0],[11,2,0]]`

Pop `[1,2]` ‚Üí push `[1,4]`
Pop `[1,4]` ‚Üí push `[1,6]`
Pop `[1,6]` ‚Üí done.

‚úÖ Output: `[[1,2],[1,4],[1,6]]`

---








## Portuguese explaination


### üß† Ideia geral

Temos dois arrays **ordenados**:

```js
nums1 = [1,7,11]
nums2 = [2,4,6]
```

E queremos os **k menores pares poss√≠veis**, onde cada par √© formado por:

* um n√∫mero do `nums1`
* e um n√∫mero do `nums2`.

Exemplo:
Todos os pares poss√≠veis s√£o:

```
[1,2], [1,4], [1,6],
[7,2], [7,4], [7,6],
[11,2], [11,4], [11,6]
```

Mas n√£o queremos todos, s√≥ os **3 com menor soma** ‚Üí `[1,2], [1,4], [1,6]`.

---

### üß© Passo a passo do algoritmo

1. **Verifica se os arrays est√£o vazios.**
   Se um deles estiver vazio, n√£o h√° pares poss√≠veis ‚Üí retorna `[]`.

   ```js
   if(nums1.length === 0 || nums2.length === 0) return [];
   ```

---

2. **Cria uma "lista de poss√≠veis pares" (heap).**
   O heap aqui √© s√≥ um **array que ser√° ordenado** a cada passo (em vez de um heap de verdade).

   Ele come√ßa pegando o **primeiro elemento de `nums2`** combinado com alguns elementos iniciais de `nums1`:

   ```js
   for (let i = 0; i < Math.min(nums1.length, k); i++) {
       heap.push([nums1[i], nums2[0], 0]);
   }
   ```

   üëâ Isso significa: ‚Äúcomece testando todos os n√∫meros de `nums1` com o primeiro n√∫mero de `nums2`‚Äù.

   Exemplo:

   ```
   heap = [
     [1, 2, 0],
     [7, 2, 0],
     [11, 2, 0]
   ]
   ```

   (o `0` no final √© o √≠ndice de onde ele est√° em `nums2`)

---

3. **Enquanto ainda faltarem pares (k > 0):**

   * Ordena o heap pelo **menor valor da soma (`num1 + num2`)**
   * Pega o **menor par** (tirando o primeiro da lista)
   * Guarda esse par no resultado

   ```js
   heap.sort((a,b) => (a[0]+a[1]) - (b[0]+b[1]));
   let [num1, num2, idx2] = heap.shift();
   result.push([num1, num2]);
   ```

---

4. **Cria o ‚Äúpr√≥ximo par poss√≠vel‚Äù com o mesmo `num1`, mas o pr√≥ximo n√∫mero de `nums2`.**

   ```js
   if (idx2 + 1 < nums2.length) {
       heap.push([num1, nums2[idx2 + 1], idx2 + 1]);
   }
   ```

   üëâ Assim, ele vai avan√ßando no `nums2` sem precisar gerar todos os pares de uma vez.

---

5. **Repete at√© achar k pares.**

   Cada vez:

   * tira o menor par da lista
   * adiciona o pr√≥ximo par com o mesmo `num1` e o pr√≥ximo `num2`.

---

### üßÆ Exemplo simplificado

Com `nums1 = [1,7,11]`, `nums2 = [2,4,6]`, `k = 3`:

| Passo | heap antes de ordenar      | Pega (menor soma) | Adiciona pr√≥ximo par | Resultado acumulado |
| ----- | -------------------------- | ----------------- | -------------------- | ------------------- |
| 1     | [[1,2,0],[7,2,0],[11,2,0]] | [1,2]             | [1,4,1]              | [[1,2]]             |
| 2     | [[7,2,0],[11,2,0],[1,4,1]] | [1,4]             | [1,6,2]              | [[1,2],[1,4]]       |
| 3     | [[7,2,0],[11,2,0],[1,6,2]] | [1,6]             | ‚Äî                    | [[1,2],[1,4],[1,6]] |

‚úÖ Pronto: encontramos os 3 menores pares.

---

### üí° Resumo bem curto

O algoritmo:

1. Come√ßa com os pares menores poss√≠veis.
2. Sempre pega o menor par atual.
3. Gera o **pr√≥ximo par poss√≠vel** s√≥ quando precisa.
4. Repete at√© achar `k` pares.


## My Brute Force Solution O(n ^2)
```javascript


/**
 * @param {number[]} nums1
 * @param {number[]} nums2
 * @param {number} k
 * @return {number[][]}
 */
var kSmallestPairs = function(nums1, nums2, k) {
  
    let result = [];

    for(let i = 0; i < nums1.length; i++){
        for(let j = 0; j < nums2.length; j++){

            result.push([nums1[i], nums2[j]]);

        }
    }


    return result.sort((a,b)=> (a[0]+a[1]) - (b[0] + b[1])).splice(0,k);

};


console.log("373. Find K Pair with smsllest Sums\n");


console.log("---------------------------------------------------------------------------------");
console.log("Test Case 01  --");
console.log("---------------------------------------------------------------------------------");
console.log("Input: (", [1,7,11], [2,4,6], ", K: 3)\nOutput:", kSmallestPairs([1,7,11], [2,4,6],3),"\nExpected: ",[[1,2],[1,4],[1,6]]);
console.log("---------------------------------------------------------------------------------");


console.log("\n")
console.log("Test Case 02  --");
console.log("---------------------------------------------------------------------------------");
console.log("Input: (",[1,1,2],[1,2,3],", K:2)\nOutput:",kSmallestPairs([1,1,2],[1,2,3], 2),"\nExpected: ", [[1,1],[1,1]]);
console.log("---------------------------------------------------------------------------------");

```